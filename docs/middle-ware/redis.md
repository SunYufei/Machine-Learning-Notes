# Redis分布式缓存

## 使用场景

- 数据库缓存
    - 缓存：原始数据的复制级，用于快速访问
- 提高系统响应
- 做 Session 分离
- 乐观锁 watch + incr
- 分布式锁（悲观锁）setnx
- MyBatis 的二级缓存

## 锁的解释

### 乐观锁：谁都可以来，但是我成功了，你就成功不了

- 性能高
- 秒杀场景

### 悲观锁：我认为会出问题，所以先上锁

- 性能差
- synchronized
- 数据库中的行锁、表锁

## 缓存的读写模式

### Redis: Cache Aside Pattern

- 读：先读缓存，缓存没有读数据库，取出数据放缓存，并返回响应
- 更：先更新数据库，再删除缓存
  - 不更新缓存原因
    - 缓存如果是一个复杂结构（hash、list），会需要遍历，增加复杂度
    - 只更新不删除有几率出现脏读情况

### Guava Cache: Read / Write Through Pattern

应用进程只操作缓存，缓存操作数据库

### EVCache: Write Behind Caching Pattern

- 应用进程只更新缓存，缓存“异步”批量更新到数据库
- 不能实时同步，甚至可能会丢数据

## 数据类型

### string 字符串

- 字符串
- 数字
- 浮点数
- 乐观锁 watch + incr
- 分布式锁（悲观锁）setnx

### list 列表

- 存储有序、可重复元素，获取头部、尾部记录极快
- 栈、队列
- 用户列表、商品列表、评论列表

### set 集合

- 无序、元素唯一
- 关注的用户
- 随机抽奖（spop 命令）

### SortedSet 有序集合

- 元素唯一，可按分数排序
- 底层实现：跳跃表
- 点击、销量、关注排行榜

### hash 散列表

- string 类型的 field、value 映射表
- 对象
- 表数据映射

### bitmap 位图

- value 只能是 0 或 1
- 用户签到
- 统计活跃用户
- 查找用户在线状态

### geo 地理位置

- 使用 Z 阶曲线、Base32 编码、GeoHash 算法，保存经纬度
- 记录地理位置
- 计算距离
- 附近的人

### stream 数据流

持久化消息队列

## 过期、淘汰策略

### maxmemory

- 如果设置了 maxmemory 则 maxmemory-policy 要配置
- 【默认】禁止驱逐
  - 可作为 DB 使用
  - 数据太多可能导致崩溃
- 【推荐】设置为物理内存的 3/4

### maxmemory-policy 删除策略

#### 定时删除

使用定时器删除过期时间的 key【不推荐】

#### 惰性删除

访问 key 发现已过期，则删除

#### 主动删除

- 随机挑选键值对，使用遍历太耗时
- no-enviction 不删除【默认】
- allkeys-lru 使用时间最远（看使用的时间）【通常采用】
- volatile-lru 从已设置过期时间的数据，挑选使用时间最远
- allkeys-lfu 最近最少使用（看使用次数）
- volatile-lfu 从已设置过期时间的数据，挑选最近最少使用
- allkeys-random 随机，希望请求压力平均分布时采用
- volatile-random 从已设置过期时间的数据，随机挑选
- volatile-ttl 挑选 TTL 值最小

### expire（TTL）

数据存活时间

## 持久化

### 目的

为了快速回复数据而非存储数据 AOF 记录过程，RDB 只管结果

### RDB 快照【默认开启】

- 流程：父进程 fork 子进程（此时父进程阻塞），子进程创建 RDB 文档，根据父进程内存生成快照文档，并对原有文档进行原子替换
- 优点：使用二进制压缩，空间小，方便传输
- 缺点
  - 无法保证数据完整，将丢失快照以后的所有数据
  - fork 子进程过程阻塞，若数据太大，将导致短时间无法响应请求（如需避免须关闭 RDB，启用 AOF）

### AOF 操作日志

将运行的命令记录到 AOF 文档中

- 优点：数据安全，不丢失数据
- 缺点：性能低
- 保存模式（硬盘）
  - AOF_FSYNC_NO 不保存
    - (1) Redis 关闭
    - (2) AOF 功能关闭
    - (3) 操作系统写缓存刷新才会将 AOF 存到硬盘
  - AOF_FSYNC_EVERYSEC 每秒保存一次【默认】最多丢失 2 秒钟数据
  - AOF_FSYNC_ALWAYS 一条命令保存一次（不推荐）最多丢失一条命令数据
- 重写：将 AOF 文件内命令进行删除与合并，对文件进行瘦身，且整个过程绝对安全

## Redis 弱事务

### 开启事务后出现错误

- 语法错误 - 命令队列清除
- 运行错误（类型错误等）- 正确的命令，运行，不会回滚【性能考量】

### Redis 的 ACID

- Atomicity（原子性）一个队列中的命令，要么运行，要么不运行
- Consistency（一致性）
  - 事务运行前后状态必须是一致的
  - Redis 是 AP 模型，集群中不能保证实时一致，只能保持最终一致
- Isolation（隔离性）命令是顺序运行，但在一个事务中，有可能运行其他客户端的命令
- Durability（持久性）有持久化，但不保证数据完整性

### 事务命令

- 当被监视的字段被其他客户端更动之后，监视后开启的命令队列将被清空
- watch 监视 key（客户端内共享）
- multi 开启事务，后续命令将放入命令队列中
- exec 运行命令队列
- discard 清除命令队列
- unwatch 清除监视 key（客户端内共享）

### Lua 脚本

- 具备强原子性
- 脚本运行过程，不允许插入新的命令，故运行时间应尽量短

## 优化

- 避免大 key（value > 100K），拆为小 key
- 避免使用 key*、hgetall 等全量操作
- RDB 改为 AOF 甚至关闭
- 添加多条数据时使用管道 pipeline
- 使用 hash 存储
- 限制内存大小，避免出现 swap 或 OOM 错误

## 高可用

### 主从复制（读写分离）

- 主可写，从不可写
- 主挂了，从不能为主
- 从服务器使用 replicaof 命令开启

### 哨兵

当主服务器下线，Sentinel 将从服务器升级为主服务器

#### 初始化

1. Sentinel 向 master 发送 info 命令，取得 slave 服务器地址，之后向 master、slave 发送 info 命令，获得 Redis 状态
2. Sentinel 向 master、slave 订阅 :hello 频道，并向频道发送自身消息，让 Sentinel 之间可以互相感知

#### Sentinel Leader 选举

1. Sentinel 每秒向 Redis 发送心跳连接，若无回应则视为【主观下线】，并向其他 Sentinel 发送查找命令，若有 quorum 数量的 Sentinel 都认为该 Redis 下线，将被判定为【客观下线】
2. 当 master 客观下线，将使用 Raft 协议选出 Leader Sentinel 运行 Redis 的【故障转移】

##### Raft 协议

- 选举开始，所有节点都是 Follower
- 如果收到 RequestVote（投票给我）、AppendEntries（已选出 Leader）的请求，则保持 Follower 状态
- 一段时间（随机）内没收到请求，则将身份转换为 Candidate 开始竞选 Leader，如果获得过半票数则成为 Leader
- 如果最后未选出 Leader，则 Term+1，开启下一轮选举

#### 故障转移

##### 选择标准

1. slave-priority 最高
2. 复制偏移量最大
3. run_id 最小（重启最少次）

##### 操作步骤

1. 选出 slave 取代原 master，并让其他 slave 复制新 master
2. 向 slave 返回新 master 地址
3. 更新所有 Redis 的 redis.conf、sentinel.conf

### Codis（Proxy）

#### 优点

- 客户端透明，和 Codis 交互与和 Redis 交互相同
- 支持在线数据迁移
- 支持高可用（Redis、Proxy）
- 数据自动均衡分配
- 支持 1024 个 Redis 支持

#### 缺点

- 某些命令不支持
- 只有一个 Codis，性能将下降 20%
- 采用自有的 Redis 分支，与原版不同步

### Redis Cluster（至少需要 6 个节点）

#### 优势

- 高性能：多主节点、负载均衡、读写分离
- 高可用：主从复制、raft 选举
- 易扩展
  - 添加、删除结点，不须停机
  - 数据分片
- 原生：不需要其他代理工具，和单机 Redis 完全兼容

#### 失效判定

- 半数以上主节点宕机（无法投票）
- 某个分区的主、从节点同时宕机（slot 槽不连续）

#### 副本漂移

集群中拥有最多从机的节点组，漂移到单点的主从节点组

## 高并发问题

### 缓存穿透

查找缓存中 key 不存在的数据，会穿透缓存去查数据库，导致 DB 压力过大

#### 解决方案

- 结果为空也进行缓存，TTL 设短一些，且在对 DB Insert 数据后清除缓存；问题：缓存空值将占用空间
- 布隆过滤器：使用布隆过滤器查找 key 是否存在，不存在则返回，存在再查缓存与 DB

### 缓存雪崩

大量缓存在同一时刻失效，导致客户端直接查找 DB，造成 DB 压力过大

#### 解决方案

- 让 key 的失效期分散
- 设置二级缓存（本地缓存），可能存在数据不一致问题
- 高可用（读写分离）

### 缓存击穿

热 key 失效，导致 DB 某个记录瞬间被大量访问

#### 解决方案

- 使用分布式锁 setnx，让其他线程处于等待状态，来保证 DB 安全
- key 不设置超时时间，过期策略使用 volatile-lru

### 数据一致性【延迟双删】

- 更新 DB 后删除缓存，读数据再填充缓存
- 2秒后再删除一次缓存
- 设置缓存过期时间 10 秒或 1 小时
- 若缓存删除失败，则记录到日志，并用脚本提取后删除（1 天）

### 大 key

- string 类型
  - 存到 MongoDB 或 CDN
  - 在 Redis 中单独存储，并且采用一主多从架构
- hash、set、zset、list 类型：元素过多，可以将 key 进行 hash 取模后生成新 key，将 key 进行分拆
- 删除使用 unlink 而非 del 命令